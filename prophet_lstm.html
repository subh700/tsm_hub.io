<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prophet-LSTM Hybrid Model - TSM Hub</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-100 text-slate-800">
<!-- Enhanced Navigation for Model Pages -->
<nav class="bg-white shadow-lg sticky top-0 z-50 mb-8">
    <div class="container mx-auto px-6 py-4">
        <div class="flex justify-between items-center">
            <div class="flex items-center space-x-4">
                <a href="index.html" class="text-2xl font-bold text-blue-600">üè† TS Forecasting Hub</a>
                <div class="hidden md:flex items-center space-x-1 bg-gray-100 rounded-lg p-1">
                    <a href="models.html" class="nav-link px-3 py-2 rounded">üìö All Models</a>
                    <a href="comparison.html" class="nav-link px-3 py-2 rounded">üìä Compare</a>
                </div>
            </div>
            
            <div class="flex items-center space-x-3">
                <!-- AI Features Quick Access -->
                <div class="hidden md:flex items-center space-x-2">
                    <a href="model-selector.html" class="bg-blue-500 text-white px-3 py-2 rounded-lg hover:bg-blue-600 text-sm flex items-center">
                        ü§ñ AI Recommender
                    </a>
                    <a href="chat.html" class="bg-green-500 text-white px-3 py-2 rounded-lg hover:bg-green-600 text-sm flex items-center">
                        üí¨ AI Assistant
                    </a>
                    <a href="forecast-simulator.html?model={{MODEL_NAME}}" class="bg-purple-500 text-white px-3 py-2 rounded-lg hover:bg-purple-600 text-sm flex items-center">
                        üöÄ Try in Simulator
                    </a>
                </div>
                
                <!-- Mobile menu button -->
                <button class="md:hidden p-2" onclick="toggleMobileMenu()">‚ò∞</button>
            </div>
        </div>
        
        <!-- Mobile Menu -->
        <div id="mobile-menu" class="hidden md:hidden mt-4 pb-4 border-t">
            <div class="flex flex-col space-y-2">
                <a href="models.html" class="text-gray-600 hover:text-blue-600 py-2">üìö All Models</a>
                <a href="comparison.html" class="text-gray-600 hover:text-blue-600 py-2">üìä Compare Models</a>
                <a href="model-selector.html" class="text-gray-600 hover:text-blue-600 py-2">ü§ñ AI Recommender</a>
                <a href="chat.html" class="text-gray-600 hover:text-blue-600 py-2">üí¨ AI Assistant</a>
                <a href="forecast-simulator.html" class="text-gray-600 hover:text-blue-600 py-2">üöÄ Simulator</a>
            </div>
        </div>
    </div>
</nav>

    <header class="bg-white shadow-md sticky top-0 z-50">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <a href="index.html" class="text-2xl font-bold text-slate-900">TSM Hub</a>
            <div class="hidden md:flex space-x-6 items-center">
                <a href="index.html" class="nav-link">Home</a>
                <a href="concepts.html" class="nav-link">Concepts</a>
                <a href="models.html" class="nav-link active">Models</a>
                <a href="comparison.html" class="nav-link">Comparison</a>
            </div>
            <button id="mobile-menu-button" class="md:hidden p-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7" />
                </svg>
            </button>
        </nav>
        <div id="mobile-menu" class="hidden md:hidden">
            <a href="index.html" class="block py-2 px-4 text-sm hover:bg-slate-200">Home</a>
            <a href="concepts.html" class="block py-2 px-4 text-sm hover:bg-slate-200">Concepts</a>
            <a href="models.html" class="block py-2 px-4 text-sm hover:bg-slate-200">Models</a>
            <a href="comparison.html" class="block py-2 px-4 text-sm hover:bg-slate-200">Comparison</a>
        </div>
    </header>

    <main class="container mx-auto p-4 md:p-8">
        <div class="bg-white p-8 rounded-lg shadow-md">
            <header class="border-b-2 border-slate-200 pb-6 mb-8">
                 <a href="models.html" class="text-blue-600 hover:underline mb-4 inline-block">&larr; Back to Model Library</a>
                <h1 class="text-4xl md:text-5xl font-bold text-slate-900">Prophet-LSTM Hybrid Model</h1>
                <p class="mt-2 text-lg text-slate-600">Combining Decomposition with Deep Learning for Residuals</p>
            </header>
            
            <article class="prose max-w-none">
                <section>
                    <h2>Overview</h2>
                    <p>The Prophet-LSTM hybrid model combines the strengths of Facebook's Prophet forecasting procedure with the powerful non-linear learning capabilities of Long Short-Term Memory (LSTM) neural networks. This hybrid approach leverages Prophet's robust decomposition of time series into trend, seasonality, and holiday effects, and then uses an LSTM model to capture any remaining complex, non-linear patterns in the residuals (the unexplained part) from the Prophet forecast. This synergy aims to provide more accurate and robust forecasts, especially for time series data that exhibits both clear, interpretable patterns and intricate, non-linear dynamics.</p>
                    
                    <h2>Architecture & Components</h2>
                    <p>The Prophet-LSTM hybrid model typically follows a two-stage sequential process:</p>
                    <ol>
                        <li><strong>Stage 1: Prophet Modeling (Trend, Seasonality, Holidays)</strong>
                            <p>A Prophet model is first applied to the raw time series data. Prophet excels at modeling piecewise linear or logistic trends, multiple seasonalities (yearly, weekly, daily) using Fourier series, and the impact of holidays. After fitting, Prophet generates in-sample predictions, and the **residuals** (the differences between the actual values and Prophet's fitted values) are calculated. These residuals are assumed to contain the non-linear patterns that Prophet's additive model could not fully capture.</p>
                            <p class="font-mono text-center bg-slate-100 p-2 rounded-md mathjax-process">
                                $ R_t = Y_t - \hat{Y}_t^{\text{Prophet}} $
                            </p>
                            Where $R_t$ are the residuals, $Y_t$ is the actual value, and $\hat{Y}_t^{\text{Prophet}}$ is Prophet's fitted value.
                        </li>
                        <li><strong>Stage 2: LSTM Modeling (Non-linear Residuals)</strong>
                            <p>An LSTM neural network is then trained on these residuals. The LSTM's ability to learn complex non-linear relationships and long-term dependencies makes it ideal for modeling the intricate patterns that remain after Prophet has accounted for the linear and seasonal components. The LSTM takes past residuals as input and learns a function to forecast the future deviation of the Prophet predictions.</p>
                            <p class="font-mono text-center bg-slate-100 p-2 rounded-md mathjax-process">
                                $ \hat{R}_t^{\text{LSTM}} = \text{LSTM}(R_{t-1}, R_{t-2}, \dots, R_{t-w}) $
                            </p>
                            Where $\hat{R}_t^{\text{LSTM}}$ is the LSTM's forecast of the residual, and $w$ is the look-back window for the LSTM.
                        </li>
                        <li><strong>Final Forecast Combination:</strong>
                            <p>The final forecast is obtained by summing the forecasts from both components: the forecast from Prophet and the non-linear residual forecast from LSTM.</p>
                            <p class="font-mono text-center bg-slate-100 p-2 rounded-md mathjax-process">
                                $ \hat{Y}_t^{\text{Hybrid}} = \hat{Y}_t^{\text{Prophet}} + \hat{R}_t^{\text{LSTM}} $
                            </p>
                        </li>
                    </ol>
                     <div class="bg-slate-100 p-4 rounded-lg my-6 text-center">
                        <img src="https://placehold.co/600x300/e2e8f0/334155?text=Conceptual+Prophet-LSTM+Hybrid+Architecture" alt="Prophet-LSTM Hybrid Architecture Diagram" class="mx-auto rounded-md">
                        <p class="text-sm text-slate-500 mt-2">Conceptual diagram of the Prophet-LSTM hybrid model, showing sequential processing.</p>
                    </div>
                </section>
                
                <section>
                    <h2>When to Use Prophet-LSTM Hybrid</h2>
                    <p>The Prophet-LSTM hybrid model is particularly effective for:</p>
                    <ul>
                        <li><strong>Time series with strong seasonality and holidays, combined with complex non-linear residuals:</strong> This is common in business data where predictable calendar effects interact with subtle, hard-to-model non-linearities.</li>
                        <li><strong>Achieving high forecasting accuracy:</strong> By combining complementary strengths, it often outperforms standalone Prophet or LSTM models.</li>
                        <li><strong>When interpretability of the trend and seasonal components is desired:</strong> Prophet provides a clear, interpretable baseline.</li>
                        <li><strong>Handling missing data and outliers:</strong> Prophet's robustness to these issues is maintained.</li>
                        <li><strong>As a robust solution for challenging time series data.</strong></li>
                    </ul>
                </section>

                <section>
                    <h2>Pros and Cons</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <h3 class="text-lg font-semibold mb-2 text-green-600">Pros</h3>
                            <ul class="list-disc list-inside text-slate-600 space-y-1">
                                <li><strong>Enhanced Accuracy:</strong> Leverages Prophet's robust handling of seasonality and holidays with LSTM's ability to capture complex non-linearities in residuals.</li>
                                <li><strong>Improved Robustness:</strong> Benefits from Prophet's resilience to missing data and outliers.</li>
                                <li><strong>Interpretability:</strong> Prophet's decomposition provides clear insights into the linear and seasonal components.</li>
                                <li><strong>Addresses Limitations:</strong> Overcomes Prophet's limitation with complex non-linearities and LSTM's need for extensive feature engineering for seasonality.</li>
                                <li><strong>Versatile:</strong> Applicable to various time series data, especially in business contexts.</li>
                            </ul>
                        </div>
                        <div>
                            <h3 class="text-lg font-semibold mb-2 text-red-600">Cons</h3>
                            <ul class="list-disc list-inside text-slate-600 space-y-1">
                                <li><strong>Increased Complexity:</strong> More challenging to implement and manage due to the need to train and integrate two separate models.</li>
                                <li><strong>Higher Computational Cost:</strong> Involves training two models sequentially, which can be time-consuming.</li>
                                <li><strong>Error Propagation:</strong> Errors from the Prophet model can propagate to the LSTM model, potentially affecting overall performance.</li>
                                <li><strong>Data Requirements:</strong> LSTMs generally require a substantial amount of data, which might be a limitation for very short series.</li>
                                <li><strong>Hyperparameter Tuning:</strong> Requires tuning parameters for both Prophet and LSTM components.</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section>
                    <h2>Example Implementation</h2>
                    <p>Implementing a Prophet-LSTM hybrid model involves several steps: fitting Prophet, extracting residuals, preparing residuals for LSTM, training LSTM, and combining forecasts. Here's a conceptual Python example demonstrating this process.</p>

                    <h3>Python Example (Conceptual)</h3>
                    <pre class="bg-yellow-100 rounded p-4 text-sm mb-2 overflow-x-auto">
                        <code class="language-python">
import pandas as pd
import numpy as np
from prophet import Prophet
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt

# 1. Generate sample data with trend, seasonality, and some non-linearity
np.random.seed(42)
n_samples = 365 * 2 # 2 years of daily data
time_idx = pd.date_range(start='2020-01-01', periods=n_samples, freq='D')

# Linear trend + strong yearly seasonality
linear_seasonal_component = 100 + 0.5 * np.arange(n_samples) + 30 * np.sin(np.arange(n_samples) * 2 * np.pi / 365)
# Add some non-linear, autoregressive-like noise (residuals for LSTM)
non_linear_residuals = np.zeros(n_samples)
for i in range(1, n_samples):
    non_linear_residuals[i] = 0.4 * non_linear_residuals[i-1] + np.random.normal(0, 2) * (1 + np.cos(i/100))

original_series = linear_seasonal_component + non_linear_residuals
df_prophet = pd.DataFrame({'ds': time_idx, 'y': original_series})

# 2. Split data into train and test sets (chronological)
train_size = int(n_samples * 0.8)
train_df_prophet, test_df_prophet = df_prophet.iloc[0:train_size], df_prophet.iloc[train_size:n_samples]
train_series_actual = df_prophet['y'].iloc[0:train_size]
test_series_actual = df_prophet['y'].iloc[train_size:n_samples]

# --- Stage 1: Prophet Modeling ---
# 3. Fit Prophet model to capture linear/seasonal patterns
m = Prophet(yearly_seasonality=True, weekly_seasonality=True, daily_seasonality=False)
m.fit(train_df_prophet)

# Create future dataframe for in-sample predictions to get residuals
future_in_sample = m.make_future_dataframe(periods=0, include_history=True)
prophet_train_pred_df = m.predict(future_in_sample)
prophet_train_pred = prophet_train_pred_df['yhat'].iloc[0:train_size]

# 4. Get Prophet in-sample residuals
prophet_residuals = train_series_actual - prophet_train_pred

print("Prophet Model Fitted.")
print(f"\nProphet Residuals (first 5): {prophet_residuals.head().values}")

# --- Stage 2: LSTM Modeling on Residuals ---
# 5. Prepare residuals for LSTM (supervised learning format)
look_back = 10 # Number of past residuals to use as input for LSTM
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_residuals = scaler.fit_transform(prophet_residuals.values.reshape(-1, 1))

def create_lstm_dataset(dataset, look_back=1):
    X, Y =,
    for i in range(len(dataset) - look_back):
        X.append(dataset[i:(i + look_back), 0])
        Y.append(dataset[i + look_back, 0])
    return np.array(X), np.array(Y)

X_residuals, y_residuals = create_lstm_dataset(scaled_residuals, look_back)

# Reshape input to be [samples, time steps, features] for LSTM
X_residuals = np.reshape(X_residuals, (X_residuals.shape, X_residuals.shape[1], 1))

# 6. Build and train LSTM model on residuals
lstm_model = Sequential()
lstm_model.add(LSTM(50, activation='relu', input_shape=(look_back, 1)))
lstm_model.add(Dense(1))
lstm_model.compile(optimizer='adam', loss='mean_squared_error')

print("\nStarting LSTM training on Prophet residuals...")
lstm_model.fit(X_residuals, y_residuals, epochs=50, batch_size=1, verbose=0) # Reduced epochs for demo
print("LSTM training complete.")

# --- Forecasting and Combination ---
# 7. Make multi-step forecasts
forecast_steps = len(test_series_actual)

# Prophet forecast for the future
future_prophet = m.make_future_dataframe(periods=forecast_steps, include_history=False)
prophet_forecast_future_df = m.predict(future_prophet)
prophet_forecast_future = prophet_forecast_future_df['yhat'].values

# LSTM forecast for future residuals (recursive prediction)
# Start with the last 'look_back' residuals from training
last_residuals_sequence = scaled_residuals[-look_back:]
lstm_future_residuals_scaled =
current_lstm_input = last_residuals_sequence.reshape(1, look_back, 1)

for _ in range(forecast_steps):
    next_residual_pred_scaled = lstm_model.predict(current_lstm_input, verbose=0)
    lstm_future_residuals_scaled.append(next_residual_pred_scaled)
    # Update input sequence: remove oldest, add new prediction
    current_lstm_input = np.append(current_lstm_input[:, 1:, :], [[[next_residual_pred_scaled]]], axis=1)

lstm_future_residuals = scaler.inverse_transform(np.array(lstm_future_residuals_scaled).reshape(-1, 1)).flatten()

# 8. Combine forecasts
hybrid_forecast = prophet_forecast_future + lstm_future_residuals

# 9. Evaluate Hybrid Model
mae = mean_absolute_error(test_series_actual, hybrid_forecast)
rmse = np.sqrt(mean_squared_error(test_series_actual, hybrid_forecast))
print(f"\nHybrid Model MAE: {mae:.3f}")
print(f"Hybrid Model RMSE: {rmse:.3f}")

# 10. Plotting Results
plt.figure(figsize=(14, 7))
plt.plot(train_df_prophet['ds'], train_series_actual, label='Training Data', color='blue')
plt.plot(test_df_prophet['ds'], test_series_actual, label='Actual Test Data', color='orange')
plt.plot(test_df_prophet['ds'], hybrid_forecast, label='Prophet-LSTM Hybrid Forecast', color='green', linestyle='--')
plt.title('Prophet-LSTM Hybrid Time Series Forecasting')
plt.xlabel('Date')
plt.ylabel('Value')
plt.legend()
plt.grid(True)
plt.show()
                        </code></pre>
                    </div>
                </section>
                
                <section>
                    <h2>Dependencies & Resources</h2>
                    <p><strong>Dependencies:</strong> <code>pandas</code>, <code>numpy</code>, <code>prophet</code>, <code>tensorflow</code>/<code>keras</code>, <code>scikit-learn</code>, <code>matplotlib</code> (for plotting).</p>
                    <ul class="list-disc list-inside space-y-2">
                        <li><a href="https://www.mdpi.com/2076-3417/11/17/7822" target="_blank" rel="noopener noreferrer">A Hybrid Forecasting Model Based on Prophet and LSTM for Time Series Prediction (MDPI Paper) ‚Üó</a></li>
                        <li><a href="https://www.researchgate.net/publication/344075730_A_Hybrid_Forecasting_Model_Based_on_ARIMA_and_Transformer" target="_blank" rel="noopener noreferrer">A Hybrid Forecasting Model Based on ARIMA and Transformer (ResearchGate) ‚Üó</a></li>
                        <li><a href="https://github.com/huytjuh/Hybrid-Time-Series-Modeling" target="_blank" rel="noopener noreferrer">Hybrid-Time-Series-Modeling GitHub Repository (includes conceptual hybrid frameworks) ‚Üó</a></li>
                    </ul>
                </section>
            </article>
        </div>
    </main>

    <footer class="text-center p-6 bg-slate-200 mt-12">
        <p class="text-slate-600 text-sm">TSM Hub: An Interactive Resource for Time Series Analysis</p>
    </footer>

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']],
                displayMath: [['$$','$$'], ['\\[','\\]']],
                processEscapes: true,
                ignoreHtmlClass: ".*",
                processHtmlClass: "mathjax-process"
            },
            skipStartupTypeset: true
        });
    </script>
    <script src="main.js"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof MathJax!== 'undefined') {
                MathJax.Hub.Queue();
            }
        });
    </script>
</body>
</html>
